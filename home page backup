// FIX: This line tells React this is a client-side component, which is necessary for hooks like useEffect and useState.
'use client';

import React, { Children, cloneElement, forwardRef, isValidElement, useEffect, useMemo, useRef, useState, useCallback, ReactNode, useImperativeHandle } from 'react';
import { motion as fm } from 'framer-motion'; // Using 'fm' alias for DockItem
import { motion, AnimatePresence, useMotionValue, useSpring, useTransform, MotionValue, TargetAndTransition, VariantLabels, Transition } from 'framer-motion';
import { Home, FolderKanban, Wrench, Trophy, Mail , Briefcase } from 'lucide-react';
import { ProjectsSection } from "./components/ProjectsSection";
import CardSwap, { Card } from './components/CardSwap';
import { SkillsSection } from './components/SkillsSection';
import { Newspaper } from 'lucide-react'; // Import a new icon for the blog
import { BlogSection } from './components/BlogSection'; // Import our new section
import { ExperienceSection } from './components/ExperienceSection';
import { AboutSection } from './components/AboutSection';
import { CertificationsSection } from './components/CertificationsSection';
import { Award } from 'lucide-react'; // A new icon for Certifications
import { Footer } from './components/Footer';


declare global {
  interface Window {
    gsap?: any;
  }
}

interface CardProps { customClass?: string; icon: ReactNode; title: string; className?: string; children: ReactNode; style?: React.CSSProperties; onClick?: (event: React.MouseEvent<HTMLDivElement>) => void; }
interface CardSwapProps { width?: number; height?: number; cardDistance?: number; verticalDistance?: number; delay?: number; pauseOnHover?: boolean; onCardClick?: (index: number) => void; skewAmount?: number; easing?: 'elastic' | 'power'; children: ReactNode; }
// Removed duplicate local declaration of RotatingTextRef
interface RotatingTextProps { texts: string[]; transition?: Transition; initial?: TargetAndTransition | VariantLabels; animate?: TargetAndTransition | VariantLabels; exit?: TargetAndTransition | VariantLabels; animatePresenceMode?: 'wait' | 'popLayout' | 'sync'; animatePresenceInitial?: boolean; rotationInterval?: number; staggerDuration?: number; staggerFrom?: 'first' | 'last' | 'center' | 'random' | number; loop?: boolean; auto?: boolean; splitBy?: 'characters' | 'words' | 'lines' | string; onNext?: (newIndex: number) => void; mainClassName?: string; splitLevelClassName?: string; elementLevelClassName?: string; }
interface DockItemData { icon: ReactNode; label: string; onClick?: () => void; }
interface DockProps { items: DockItemData[]; }
interface DockItemProps { mouseX: MotionValue<number>; item: DockItemData; }
// FIX: Define the props and data shape for Dock components
interface DockItemData {
  icon: ReactNode;
  label: string;
  onClick?: () => void;
}

interface DockProps {
  items: DockItemData[];
}

interface DockItemProps {
  mouseX: MotionValue<number>;
  item: DockItemData;
}

// --- RotatingText Component ---
// FIX: Type the function parameter
function cn(...classes: (string | undefined | null | boolean)[]): string {
  return classes.filter(Boolean).join(" ");
}

// FIX: Define the shape of the functions exposed by useImperativeHandle
export interface RotatingTextRef {
  next: () => void;
  previous: () => void;
  jumpTo: (index: number) => void;
  reset: () => void;
}

const RotatingText = forwardRef<RotatingTextRef, RotatingTextProps>((props, ref) => {
  const {
    texts,
    transition = { type: "spring", damping: 25, stiffness: 300 },
    initial = { y: "100%", opacity: 0 },
    animate = { y: 0, opacity: 1 },
    exit = { y: "-120%", opacity: 0 },
    animatePresenceMode = "wait",
    animatePresenceInitial = false,
    rotationInterval = 2000,
    staggerDuration = 0,
    staggerFrom = "first",
    loop = true,
    auto = true,
    splitBy = "characters",
    onNext,
    mainClassName,
    splitLevelClassName,
    elementLevelClassName,
    ...rest
  } = props;

  const [currentTextIndex, setCurrentTextIndex] = useState(0);

  const splitIntoCharacters = (text: string) => {
    if (typeof Intl !== "undefined" && Intl.Segmenter) {
      const segmenter = new Intl.Segmenter("en", { granularity: "grapheme" });
      return Array.from(segmenter.segment(text), (segment) => segment.segment);
    }
    return Array.from(text);
  };

  const elements = useMemo(() => {
    const currentText = texts[currentTextIndex];
    if (splitBy === "characters") {
      const words = currentText.split(" ");
      return words.map((word, i) => ({
        characters: splitIntoCharacters(word),
        needsSpace: i !== words.length - 1,
      }));
    }
    if (splitBy === "words") {
      return currentText.split(" ").map((word, i, arr) => ({
        characters: [word],
        needsSpace: i !== arr.length - 1,
      }));
    }
    if (splitBy === "lines") {
      return currentText.split("\n").map((line, i, arr) => ({
        characters: [line],
        needsSpace: i !== arr.length - 1,
      }));
    }

    return currentText.split(splitBy).map((part, i, arr) => ({
      characters: [part],
      needsSpace: i !== arr.length - 1,
    }));
  }, [texts, currentTextIndex, splitBy]);

  const getStaggerDelay = useCallback(
    (index: number, totalChars: number) => {
      const total = totalChars;
      if (staggerFrom === "first") return index * staggerDuration;
      if (staggerFrom === "last") return (total - 1 - index) * staggerDuration;
      if (staggerFrom === "center") {
        const center = Math.floor(total / 2);
        return Math.abs(center - index) * staggerDuration;
      }
      if (staggerFrom === "random") {
        const randomIndex = Math.floor(Math.random() * total);
        return Math.abs(randomIndex - index) * staggerDuration;
      }
      if (typeof staggerFrom === 'number') {
        return Math.abs(staggerFrom - index) * staggerDuration;
      }
      return 0; // Fallback
    },
    [staggerFrom, staggerDuration]
  );

  const handleIndexChange = useCallback(
    (newIndex: number) => {
      setCurrentTextIndex(newIndex);
      onNext?.(newIndex);
    },
    [onNext]
  );

  const next = useCallback(() => {
    const nextIndex =
      currentTextIndex === texts.length - 1
        ? loop
          ? 0
          : currentTextIndex
        : currentTextIndex + 1;
    if (nextIndex !== currentTextIndex) {
      handleIndexChange(nextIndex);
    }
  }, [currentTextIndex, texts.length, loop, handleIndexChange]);

  const previous = useCallback(() => {
    const prevIndex =
      currentTextIndex === 0
        ? loop
          ? texts.length - 1
          : currentTextIndex
        : currentTextIndex - 1;
    if (prevIndex !== currentTextIndex) {
      handleIndexChange(prevIndex);
    }
  }, [currentTextIndex, texts.length, loop, handleIndexChange]);

  const jumpTo = useCallback(
    (index: number) => {
      const validIndex = Math.max(0, Math.min(index, texts.length - 1));
      if (validIndex !== currentTextIndex) {
        handleIndexChange(validIndex);
      }
    },
    [texts.length, currentTextIndex, handleIndexChange]
  );

  const reset = useCallback(() => {
    if (currentTextIndex !== 0) {
      handleIndexChange(0);
    }
  }, [currentTextIndex, handleIndexChange]);

  useImperativeHandle(
    ref,
    () => ({
      next,
      previous,
      jumpTo,
      reset,
    }),
    [next, previous, jumpTo, reset]
  );

  useEffect(() => {
    if (!auto) return;
    const intervalId = setInterval(next, rotationInterval);
    return () => clearInterval(intervalId);
  }, [next, rotationInterval, auto]);

  return (
    <motion.span
      className={cn("text-rotate", mainClassName)}
      {...rest}
      layout
      transition={transition}
    >
      <span className="text-rotate-sr-only">{texts[currentTextIndex]}</span>
      <AnimatePresence mode={animatePresenceMode} initial={animatePresenceInitial}>
        <motion.span
          key={currentTextIndex}
          className={cn(
            splitBy === "lines" ? "text-rotate-lines" : "text-rotate"
          )}
          layout
          aria-hidden="true"
        >
          {elements.map((wordObj, wordIndex, array) => {
            const previousCharsCount = array
              .slice(0, wordIndex)
              .reduce((sum, word) => sum + word.characters.length, 0);
            return (
              <span
                key={wordIndex}
                className={cn("text-rotate-word", splitLevelClassName)}
              >
                {wordObj.characters.map((char, charIndex) => (
                  <motion.span
                    key={charIndex}
                    initial={initial}
                    animate={animate}
                    exit={exit}
                    transition={{
                      ...transition,
                      delay: getStaggerDelay(
                        previousCharsCount + charIndex,
                        array.reduce(
                          (sum, word) => sum + word.characters.length,
                          0
                        )
                      ),
                    }}
                    className={cn("text-rotate-element", elementLevelClassName)}
                  >
                    {char}
                  </motion.span>
                ))}
                {wordObj.needsSpace && (
                  <span className="text-rotate-space"> </span>
                )}
              </span>
            );
          })}
        </motion.span>
      </AnimatePresence>
    </motion.span>
  );
});

RotatingText.displayName = "RotatingText";


// --- Main App Component ---
const App = () => {
  const handleScrollTo = (id: string) => {
    const element = document.getElementById(id);
    if (element) {
      element.scrollIntoView({ behavior: 'smooth' });
    }
  };

  const dockItems: DockItemData[] = [
    { icon: <Home size={22} />, label: 'Home', onClick: () => handleScrollTo('home') },
    { icon: <Briefcase size={22} />, label: 'Experience', onClick: () => handleScrollTo('experience') },
    { icon: <FolderKanban size={22} />, label: 'Projects', onClick: () => handleScrollTo('projects') },
    { icon: <Wrench size={22} />, label: 'Skills', onClick: () => handleScrollTo('skills') },
    { icon: <Newspaper size={22} />, label: 'Blog', onClick: () => handleScrollTo('blog') },
    { icon: <Award size={22} />, label: 'Certifications', onClick: () => handleScrollTo('certifications') },
    
  ];
  
  const skills = ["C++", "Java", "Javascript", "Python", "HTML", "CSS", "React", "Next.js", "Node.js"];
  const [menuOpen, setMenuOpen] = useState(false);

  return (
    <div className="font-sans">
      <style>{`
        /* Your final, cleaned-up styles */
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        .font-fredoka { font-family: 'Fredoka', sans-serif; }
        .text-rotate { display: inline-flex; align-items: center; vertical-align: middle; }
        .text-rotate-sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
        .text-rotate-lines { display: flex; flex-direction: column; }
        .text-rotate-word { display: inline-flex; }
        .text-rotate-element { display: inline-block; }
        .text-rotate-space { display: inline-block; width: 0.25em; }
      `}</style>
      <div className="min-h-screen bg-slate-50 text-slate-800 relative overflow-y-auto">
        <header className="fixed top-0 left-0 right-0 h-20 bg-white/80 backdrop-blur-lg border-b border-slate-200 shadow-sm z-40 flex items-center justify-between px-6">
  <h1 className="text-xl font-semibold tracking-wide text-slate-900">
    Abhishek Kumar Singh
  </h1> 

  {/* Desktop Dock */}
  <div className="hidden lg:flex">
    <Dock items={dockItems} />
  </div>

  {/* Mobile Hamburger */}
  <div className="lg:hidden">
    <button onClick={() => setMenuOpen(!menuOpen)} className="p-2 text-2xl">
      {menuOpen ? "‚úï" : "‚ò∞"}
    </button>
  </div>
</header>
{menuOpen && (
  <div className="fixed top-0 right-0 w-2/3 h-full bg-white shadow-xl p-6 z-50">
    <button onClick={() => setMenuOpen(false)} className="mb-6 text-2xl">
      ‚úï
    </button>
    <nav className="mt-4 flex flex-col gap-4 text-lg font-medium">
      <a href="#home" onClick={() => setMenuOpen(false)}>Home</a>
      <a href="#experience" onClick={() => setMenuOpen(false)}>Experience</a>
      <a href="#projects" onClick={() => setMenuOpen(false)}>Projects</a>
      <a href="#skills" onClick={() => setMenuOpen(false)}>Skills</a>
      <a href="#blog" onClick={() => setMenuOpen(false)}>Blog</a>
      <a href="#contact" onClick={() => setMenuOpen(false)}>Contact</a>
    </nav>
  </div>
)}


        <main id="home" className="h-screen w-full flex items-center pt-20 px-6">
  <div className="w-full flex items-center justify-center">
    {/* ‚¨áÔ∏è Added relative + overflow-hidden here */}
    <div className="relative w-full max-w-7xl h-auto lg:h-[80vh] max-h-[650px] bg-white rounded-3xl border border-slate-200 shadow-xl p-6 lg:p-12 flex flex-col lg:flex-row items-center justify-between gap-8 overflow-hidden">

      
      {/* --- Left Column: Text --- */}
      <div className="max-w-2xl"> 
        <h3 className="text-2xl font-bold tracking-tight text-slate-600 mb-4">
          Hey, I'm glad you're here üöÄ
        </h3>
        <h1 className="text-4xl sm:text-5xl lg:text-6xl font-extrabold tracking-tighter text-slate-900 mb-6 leading-none">
          I&apos;m Abhishek üòé
        </h1>
        <h2 className="text-2xl md:text-5xl font-bold tracking-tighter text-slate-800 leading-tight">
          <div>Building cool stuff for the web,</div>
          <div>one idea at a time‚ö°</div>
        </h2>
        <div className="pt-16 text-left">
          <div className="text-3xl md:text-4xl font-bold tracking-tighter text-slate-800">
            My toolbox includes:
          </div>
          <div className="mt-4">
            <RotatingText
              texts={skills}
              mainClassName="px-4 bg-blue-500 text-white overflow-hidden py-3 justify-start rounded-lg text-4xl font-fredoka"
              staggerFrom={"last"}
              staggerDuration={0.025}
              rotationInterval={2000}
            />
          </div>
        </div>
      </div>

      {/* --- Right Column: Card Stack (absolute in corner) --- */}
      <div className="hidden lg:block">
        <div className="absolute bottom-0 right-0 translate-x-1/4 translate-y-1/4">
          <CardSwap
            width={550}
            height={450}
            cardDistance={40}
            verticalDistance={40}
            skewAmount={4}
            delay={3000}
            pauseOnHover={false}
          >
            <Card>
              <div className="p-6">
                <h3 className="text-2xl font-bold">Tech Creator</h3>
                <p className="mt-2">Designing and building modern web experiences.</p>
              </div>
            </Card>
            <Card>
              <div className="p-6">
                <h3 className="text-2xl font-bold">Code Engineer</h3>
                <p className="mt-2">Writing clean, efficient, and scalable code.</p>
              </div>
            </Card>
            <Card>
              <div className="p-6">
                <h3 className="text-2xl font-bold">Digital Builder</h3>
                <p className="mt-2">Bringing ideas to life from concept to deployment.</p>
              </div>
            </Card>
          </CardSwap>
        </div>
      </div>
        
    </div>
  </div>
</main>


        {/* --- Section 2: PROJECTS --- */}
        <AboutSection />
        <ExperienceSection />
        <ProjectsSection />
        <SkillsSection />
        <BlogSection />
        <CertificationsSection />
        <Footer />
        

      </div>
    </div>
  );
}
        

// Dock Component
const Dock = ({ items }: DockProps) => {
  const mouseX = useMotionValue(Infinity)
  const dockRef = useRef<HTMLDivElement>(null)

  return (
    <div
      ref={dockRef}
      className="relative flex justify-center"
      onMouseMove={e => mouseX.set(e.pageX)}
      onMouseLeave={() => mouseX.set(Infinity)}
    >
      <div className="flex items-center h-16 p-1 bg-slate-100 rounded-2xl border border-slate-200">
        {items.map((item, index) => (
          <DockItem key={index} mouseX={mouseX} item={item} />
        ))}
      </div>
    </div>
  )
}

// DockItem Component
const DockItem = ({ mouseX, item }: DockItemProps) => {
  const itemRef = useRef<HTMLDivElement>(null)
  const baseSize = 48

  const distance = useTransform(mouseX, val => {
    const bounds = itemRef.current?.getBoundingClientRect() ?? { x: 0, width: 0 }
    return val - bounds.x - bounds.width / 2
  })

  const springConfig = { mass: 0.1, stiffness: 200, damping: 15 }

  const scale = useSpring(
    useTransform(distance, [-80, 0, 80], [1, 1.35, 1]),
    springConfig,
  )

  const y = useSpring(
    useTransform(distance, [-80, 0, 80], [0, -16, 0]),
    springConfig,
  )

  return (
    <motion.div
      ref={itemRef}
      style={{ width: baseSize, height: baseSize }}
      className="group relative flex items-center justify-center mx-1"
      onClick={item.onClick}
    >
      <motion.div
        className="flex items-center justify-center text-slate-600 cursor-pointer bg-white rounded-full w-10 h-10 shadow-sm border border-slate-200/50"
        style={{ scale, y }}
      >
        {item.icon}
      </motion.div>

      <motion.div
        style={{ y }}
        className="absolute top-full mt-2 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none"
      >
        <div className="bg-slate-900 text-white text-xs rounded-md py-1 px-2 whitespace-nowrap">
          {item.label}
        </div>
        <svg
          className="absolute text-slate-900 h-2 w-full left-0 bottom-full"
          x="0px"
          y="0px"
          viewBox="0 0 255 255"
        >
          <polygon className="fill-current" points="0,127.5 127.5,0 255,127.5" />
        </svg>
      </motion.div>
    </motion.div>
  )
}

export default App
